function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const LevelQueue = require('../level-queue');
const AsyncDeckLoader = require('../async-deck-loader');
const DefaultCardRenderer = require('../dumb-card-renderer');
const shuffle = require('knuth-shuffle').knuthShuffle;

const DEFAULT_LEARNED_THRESHOLD = 30;
const DEFAULT_HPQ_CAPACITY = 8;
const DEFAULT_LPQ_CAPACITY = 24;

class LearningStrategy {

  constructor(args) {
    args = args || {};
    const { hpq, hpqCapacity, lpq, done, backlog, learnedThreshold, CardRenderer } = args;
    this.hpq = hpq;
    this.hpqCapacity = hpqCapacity || DEFAULT_HPQ_CAPACITY;
    this.lpq = lpq;
    this.done = done;
    this.backlog = backlog;
    this.learnedThreshold = learnedThreshold || DEFAULT_LEARNED_THRESHOLD;
    this.CardRenderer = CardRenderer || DefaultCardRenderer;
  }

  static fromDeckName(deckName, options = {}) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const Queue = options.Queue || LevelQueue;
      const deckLoader = options.deckLoader || new AsyncDeckLoader(deckName);
      const hpqCapacity = options.hpqCapacity || DEFAULT_HPQ_CAPACITY;
      const lpqCapacity = options.lpqCapacity || DEFAULT_LPQ_CAPACITY;
      const CardRenderer = deckLoader.getCardRenderer() || DefaultCardRenderer;
      const shuffleCards = typeof options.shuffleCards === 'undefined' ? true : options.shuffleCards;

      let hpqContents = [];
      let lpqContents = [];
      let backlogContents = [];
      let doneContents = [];

      const isLoaded = yield deckLoader.isLoaded();
      if (!isLoaded) {
        const deck = deckLoader.load();
        if (shuffleCards) {
          shuffle(deck);
        }
        const scoredCards = deck.map(function (data, index) {
          return {
            card: {
              id: index,
              data
            },
            correctCount: 0
          };
        });

        hpqContents = scoredCards.slice(0, hpqCapacity);
        lpqContents = scoredCards.slice(hpqCapacity, hpqCapacity + lpqCapacity);
        backlogContents = scoredCards.slice(hpqCapacity + lpqCapacity);

        yield deckLoader.setLoaded(true);
      }

      const db = deckLoader.getStorage();
      const hpq = yield Queue.initialize(hpqContents, {
        db,
        queueName: 'hpq'
      });

      const lpq = yield Queue.initialize(lpqContents, {
        db,
        queueName: 'lpq'
      });

      const backlog = yield Queue.initialize(backlogContents, {
        db,
        queueName: 'backlog'
      });

      const done = yield Queue.initialize(doneContents, {
        db,
        queueName: 'done'
      });

      return new _this({
        hpq,
        hpqCapacity,
        lpq,
        backlog,
        done,
        learnedThreshold: DEFAULT_LEARNED_THRESHOLD,
        CardRenderer
      });
    })();
  }

  getNextCard() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const scoredCard = yield _this2.hpq.peek();
      if (scoredCard) {
        return _this2.CardRenderer.render(scoredCard.card);
      }
    })();
  }

  submitCard(id, correct) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const removed = yield _this3.hpq.remove(function ({ card }) {
        return card.id === id;
      });
      if (!removed.length) {
        throw new Error(`Card with id ${id} does not exist!`);
      }

      const { card, correctCount } = removed[0];
      const increment = correct ? 1 : -1;
      const updatedScoredCard = {
        card,
        correctCount: correctCount + increment
      };

      if (_this3._cardIsLearned(updatedScoredCard)) {
        yield _this3.done.enqueue(updatedScoredCard);
        const nextScoredCard = yield _this3.backlog.dequeue();
        nextScoredCard && (yield _this3.hpq.enqueue(nextScoredCard));
      } else if (correct) {
        yield _this3.lpq.enqueue(updatedScoredCard);
        const nextScoredCard = yield _this3.lpq.dequeue();
        nextScoredCard && (yield _this3.hpq.enqueue(nextScoredCard));
      } else {
        yield _this3.hpq.enqueue(updatedScoredCard);
      }
    })();
  }

  _cardIsLearned(scoredCard) {
    return scoredCard.correctCount >= this.learnedThreshold;
  }
}

module.exports = LearningStrategy;