function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const expect = require('expect');
const { it, mock } = require('mocha-mock');
const LearningStrategy = require('./');

// hacked mock queue object lol
const MockQueue = {
  peek: () => {},
  enqueue: () => {},
  dequeue: () => {},
  remove: () => {},
  getLength: () => {}
};

describe('learning-strategy', () => {
  describe('unit', () => {
    it('can get the next card', _asyncToGenerator(function* () {
      const scoredCard = ScoredCardBuilder.create().build();
      const renderedCard = 'a rendered card';
      const hpq = mock(MockQueue).shouldReceive('peek').once().andReturn(scoredCard);
      const CardRenderer = mock({ render: function () {} }).shouldReceive('render').once().with(scoredCard.card).andReturn(renderedCard);

      const learningStrategy = new LearningStrategy({ hpq, CardRenderer });
      expect((yield learningStrategy.getNextCard())).toBe(renderedCard);
    }));

    it('can move the card from the HPQ to the back of the LPQ', _asyncToGenerator(function* () {
      const scoredCard = ScoredCardBuilder.create().build();
      const updatedScoredCard = {
        card: scoredCard.card,
        correctCount: scoredCard.correctCount + 1
      };
      const topScoredCardInLpq = ScoredCardBuilder.create().build();

      const hpq = mock(MockQueue).shouldReceive('remove').once().andReturn([scoredCard]).shouldReceive('enqueue').once().with(topScoredCardInLpq);
      const lpq = mock(MockQueue).shouldReceive('enqueue').once().with(updatedScoredCard).shouldReceive('dequeue').once().andReturn(topScoredCardInLpq);

      const learningStrategy = new LearningStrategy({ hpq, lpq });
      yield learningStrategy.submitCard(scoredCard.card.id, true);
    }));

    it('can move the card from the HPQ to the back of the HPQ', _asyncToGenerator(function* () {
      const scoredCard = ScoredCardBuilder.create().build();
      const updatedScoredCard = {
        card: scoredCard.card,
        correctCount: scoredCard.correctCount - 1
      };

      const hpq = mock(MockQueue).shouldReceive('remove').once().andReturn([scoredCard]).shouldReceive('enqueue').once().with(updatedScoredCard);

      const learningStrategy = new LearningStrategy({ hpq });
      yield learningStrategy.submitCard(scoredCard.card.id, false);
    }));

    it('can move the card from the HPQ to Done', _asyncToGenerator(function* () {
      const learnedThreshold = 1;
      const scoredCard = ScoredCardBuilder.create().withCorrectCount(learnedThreshold).build();
      const updatedScoredCard = {
        card: scoredCard.card,
        correctCount: scoredCard.correctCount + 1
      };
      const topScoredCardInBacklog = ScoredCardBuilder.create().build();

      const hpq = mock(MockQueue).shouldReceive('remove').once().andReturn([scoredCard]).shouldReceive('enqueue').once().with(topScoredCardInBacklog);
      const done = mock(MockQueue).shouldReceive('enqueue').once().with(updatedScoredCard);
      const backlog = mock(MockQueue).shouldReceive('dequeue').once().andReturn(topScoredCardInBacklog);

      const learningStrategy = new LearningStrategy({ hpq, done, backlog, learnedThreshold });
      yield learningStrategy.submitCard(scoredCard.card.id, true);
    }));
  });

  describe('service', () => {
    it('can instantiate a learning-strategy from an already loaded deck', _asyncToGenerator(function* () {
      const deckName = 'spanish';

      const mockStorage = mock({});
      const mockDeckLoader = mock({
        isLoaded: function () {},
        getCardRenderer: function () {},
        getStorage: function () {}
      }).shouldReceive('getCardRenderer').once().shouldReceive('isLoaded').once().andReturn(true).shouldReceive('getStorage').once().andReturn(mockStorage);

      // hackedy mock because mocha-mock doesn't support mocking classes right meow
      const MockQueueClass = mock({ initialize: function () {} }).shouldReceive('initialize').with([], {
        db: mockStorage,
        queueName: 'hpq'
      }).shouldReceive('initialize').with([], {
        db: mockStorage,
        queueName: 'lpq'
      }).shouldReceive('initialize').with([], {
        db: mockStorage,
        queueName: 'backlog'
      }).shouldReceive('initialize').with([], {
        db: mockStorage,
        queueName: 'done'
      });

      const learningStrategy = yield LearningStrategy.fromDeckName(deckName, {
        Queue: MockQueueClass,
        deckLoader: mockDeckLoader
      });

      expect(learningStrategy).toBeTruthy();
    }));

    it('can instantiate a learning-strategy from a not already loaded deck', _asyncToGenerator(function* () {
      const deckName = 'spanish';
      const deck = ['hpq card', 'lpq card', 'backlog card'];
      const hpqContents = [{
        card: {
          id: 0,
          data: deck[0]
        },
        correctCount: 0
      }];

      const lpqContents = [{
        card: {
          id: 1,
          data: deck[1]
        },
        correctCount: 0
      }];

      const backlogContents = [{
        card: {
          id: 2,
          data: deck[2]
        },
        correctCount: 0
      }];

      const mockStorage = mock({});
      const mockDeckLoader = mock({
        isLoaded: function () {},
        load: function () {},
        setLoaded: function () {},
        getCardRenderer: function () {},
        getStorage: function () {}
      }).shouldReceive('getCardRenderer').once().shouldReceive('isLoaded').once().andReturn(Promise.resolve(false)).shouldReceive('load').once().andReturn(deck).shouldReceive('setLoaded').once().with(true).shouldReceive('getStorage').once().andReturn(mockStorage);

      // hackedy mock because mocha-mock doesn't support mocking classes right meow :(
      const MockQueueClass = mock({ initialize: function () {} }).shouldReceive('initialize').with(hpqContents, {
        db: mockStorage,
        queueName: 'hpq'
      }).shouldReceive('initialize').with(lpqContents, {
        db: mockStorage,
        queueName: 'lpq'
      }).shouldReceive('initialize').with(backlogContents, {
        db: mockStorage,
        queueName: 'backlog'
      }).shouldReceive('initialize').with([], {
        db: mockStorage,
        queueName: 'done'
      });

      const learningStrategy = yield LearningStrategy.fromDeckName(deckName, {
        Queue: MockQueueClass,
        deckLoader: mockDeckLoader,
        hpqCapacity: 1,
        lpqCapacity: 1,
        shuffleCards: false
      });

      expect(learningStrategy).toBeTruthy();
    }));
  });
});

class ScoredCardBuilder {
  constructor() {
    this.data = 'card data';
    this.id = Math.random();
    this.correctCount = 0;
  }

  static create() {
    return new this();
  }

  withData(data) {
    this.data = data;
    return this;
  }

  withId(id) {
    this.id = id;
    return this;
  }

  withCorrectCount(correctCount) {
    this.correctCount = correctCount;
    return this;
  }

  build() {
    const card = {
      data: this.data,
      id: this.id
    };

    return {
      card,
      correctCount: this.correctCount
    };
  }
}