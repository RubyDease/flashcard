var _this = this;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const LevelQueue = require('./');
const expect = require('expect');
const DB = require('../level-db-wrapper');

describe('level-queue', () => {
  beforeEach(() => {
    _this.queue = new LevelQueue({
      db: new DB('mydb', { adapter: 'memory' }),
      queueName: 'queueName'
    });
  });

  afterEach(() => {
    return _this.queue.destroy();
  });

  it('peek returns undefined for empty queue', _asyncToGenerator(function* () {
    const peeked = yield _this.queue.peek();
    expect(peeked).toBe(undefined);
  }));

  it('can enqueue an item', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const peeked = yield _this.queue.peek();
    expect(peeked).toBe(item);
    yield _this.queue.destroy();
  }));

  it('can dequeue an item', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const dequeued = yield _this.queue.dequeue(item);
    expect(dequeued).toBe(item);
    yield _this.queue.destroy();
  }));

  it('can enqueue many items', _asyncToGenerator(function* () {
    const items = [1, 2];
    yield _this.queue.enqueueMany(items);
    const firstDequeued = yield _this.queue.dequeue();
    const secondDequeued = yield _this.queue.dequeue();
    expect(firstDequeued).toBe(items[0]);
    expect(secondDequeued).toBe(items[1]);
  }));

  it('gets the length of an empty queue', _asyncToGenerator(function* () {
    const length = yield _this.queue.getLength();
    expect(length).toBe(0);
  }));

  it('gets the length of a non empty queue', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const length = yield _this.queue.getLength();
    expect(length).toBe(1);
  }));

  it('can remove an item', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const removed = yield _this.queue.remove(function (value) {
      return value === item;
    });
    expect(removed).toEqual([item]);
  }));
});

describe('static level-queue methods', () => {
  it('has an asynchrous initializer', _asyncToGenerator(function* () {
    const item = 'item';
    const queue = yield LevelQueue.initialize([item], {
      db: new DB('mydb', { adapter: 'memory' }),
      queueName: 'queueName'
    });
    const peeked = yield queue.peek();
    expect(peeked).toBe(item);

    // clean up
    yield queue.destroy();
  }));
});