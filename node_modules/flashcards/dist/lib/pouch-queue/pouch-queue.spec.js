var _this = this;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const PouchQueue = require('./');
const expect = require('expect');

const OPTIONS = {
  dbName: 'dbName',
  queueName: 'queueName',
  options: { adapter: 'memory' }
};

describe('pouch-queue', () => {
  beforeEach(() => {
    _this.queue = new PouchQueue(OPTIONS);
  });

  afterEach(() => {
    return _this.queue.destroy();
  });

  it('peek returns undefined for empty queue', _asyncToGenerator(function* () {
    const peeked = yield _this.queue.peek();
    expect(peeked).toBe(undefined);
  }));

  it('can enqueue an item', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const peeked = yield _this.queue.peek();
    expect(peeked).toBe(item);
  }));

  it('can enqueue many items', _asyncToGenerator(function* () {
    const items = [1, 2];
    yield _this.queue.enqueueMany(items);
    const firstDequeued = yield _this.queue.dequeue();
    const secondDequeued = yield _this.queue.dequeue();
    expect(firstDequeued).toBe(items[0]);
    expect(secondDequeued).toBe(items[1]);
  }));

  it('gets the length of an empty queue', _asyncToGenerator(function* () {
    const length = yield _this.queue.getLength();
    expect(length).toBe(0);
  }));

  it('gets the length of a non empty queue', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const length = yield _this.queue.getLength();
    expect(length).toBe(1);
  }));

  it('can dequeue an item', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const dequeued = yield _this.queue.dequeue(item);
    expect(dequeued).toBe(item);
  }));

  it('can remove an item', _asyncToGenerator(function* () {
    const item = 'item';
    yield _this.queue.enqueue(item);
    const removed = yield _this.queue.remove(function (value) {
      return value === item;
    });
    expect(removed).toEqual([item]);
  }));
});

describe('static pouch-queue methods', () => {
  it('has an asynchrous initializer', _asyncToGenerator(function* () {
    const item = 'item';
    const queue = yield PouchQueue.initialize([item], OPTIONS);
    const peeked = yield queue.peek();
    expect(peeked).toBe(item);

    // clean up
    yield queue.destroy();
  }));

  it('can set default queue options', () => {
    const defaultOptions = {
      dbName: 'custom dbName',
      queueName: 'custom queueName',
      options: {
        adapter: 'memory'
      }
    };

    PouchQueue.defaults(defaultOptions);
    const queue = new PouchQueue();
    expect(queue.queueName).toBe(defaultOptions.queueName);
  });
});